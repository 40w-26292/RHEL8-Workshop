:sectnums:
:sectnumlevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

:toc:
:toclevels: 1

= BPF Tracing - Observability of System Performance

eBPF (The Extended Berkeley Packet Filter) is an in-kernel virtual machine that allows code execution in the kernel space, in a restricted sandbox environment with access to a limited set of functions. There are numerous components shipped by Red Hat that utilize the eBPF virtual machine. Each component is in a different development phase, and thus not all components are currently fully supported. Those that are not supported are avaialable as a *Technology Preview* and are not intended for production use.For information on Red Hat scope of support for Technology Preview features, see: link:https://access.redhat.com/support/offerings/techpreview/[Technology Preview Features Support Scope]

In this unit, we will be focusing on the kernel tracing offering shipped as bcc-tools (BPF Compiler Collection Tools). There are just over 100 tools shipped in this package. A few things of note:

     * All of these tools live in `/usr/share/bcc/tools`.
     * These tools must run as the root user as any eBPF program can read kernel data. As such, injecting eBPF bytecode as a regular user is not allowed in RHEL 8.
     * Each tool has a man page to view the man page, run `man <tool name>`. These man pages include descriptions of the tools, provide the options that can be called and have information on the expected overhead of the specific tool.

TIP: Now is a great time to use the multi session capability of *tmux*.  Using `Ctrl-b c` create another session.  You can now cycle back and forth between them with `CTRL-b n` (next) and `CTRL-b p` (previous).  Just make sure you are the user *root* on *workstation.example.com* in order to sucessfully run the rootkit script.

== Getting Started

There is a dedicated VM we will use for the container exercises.  From *workstation.example.com*, you should be able to ssh to *node2.example.com* as 'root' without any prompts for credentials.

.[root@workstation ~]#
----
ssh node2.example.com
----

Verify that you are on the right host for these exercises.

.[root@node2]#
----
hostname
----
Your output should look like:
----
node2.example.com
----

Now you are ready to begin your exercises with eBPF Tracing.

== Installation

Start by installing the *BPF Compiler Collection* bcc-tools package and bpftool:

.[root@node2 ~]#
----
yum install bcc-tools bpftool -y
----

== Observing `yum update`

In this lab, we will be using some of the tools from the bcc-tools package to analyse what happens on a system during a `yum update`. We have picked `yum update` because it represents a non-trivial real world applicatio. In a `yum update`, we have the following activity happening:

     * TCP connections are established to configured repositories, which we will track with `gethostlatency` and `tcplife`.
     * Many files will be opened on our ext4 filesystem, which we will observe with `filetop`. We will also use `ext4slower` to determine which ext4 operations take longer than 10ms to execute.
     * Memory access. Linux uses a memory cache to ensure faster access to needed information than having to go to disk. Using cachestat, we will be able to see hits and misses on this cache in realtime. When everything Linux needs is chaced, we should have zero misses and while the cache is being populated, we will see a number of misses. If the cache continues to be populated beyond the size of the cache, Linux will employ a LRU (Least Recently Used) algorithm with a lot of heuristics and some cached data will be removed and replaced with new data.

To get started, let's run `bpftool` to verify that no eBPF programs are currently loaded in the kernel:

.[root@node2 ~]#
----
bpftool prog list
----

We should immediately be returned to the same prompt with no output. 

=== Setting up our observability terminals

Now that we've verified, that, let's open 5 new terminals and in each of those terminals, we will start a tool for observing the system. By doing this, we'll be able to move between the 5 terminals to observe what's happening while the `yum update` is running.

In the first new terminal, run:

.[root@node2 ~]#
----
/usr/share/bcc/tools/gethostlatency
----

We should see this header in the gethostlatency terminal, indicating the tool is properly running:

----
TIME      PID    COMM                  LATms HOST
----

In the gethostlatency terminal, we are running gethostlatency, and this is going to give us latency statistics on the getaddrinfo() and gethostbyname() system calls. Effectively, we'll get to see how long these take and which hostnames our applications need IP addresses for. This can be useful for discovering interesting connections that you may not be aware your applications are making.

In the second new terminal, run:

.[root@node2 ~]#
----
/usr/share/bcc/tools/tcplife
----

We should see this header in the tcplife terminal, indicating the tool is properly running:

----
PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
----

In the tcplife terminal, we are running tcplife and this will tell us a lot of data about established tcp connections, and the total time that the connection was alive. When yum is finished downloading packages, we should get entries in tcplife for the amount of time that yum spent downloading packages over the tcp connections that it established for this activity.

In the third new terminal, run:

.[root@node2 ~]#
----
/usr/share/bcc/tools/filetop
----

In the filetop terminal, we should see a top like tool that refreshes every second with a header that looks like:

----
09:08:28 loadavg: 0.26 0.48 0.72 1/817 76893

TID    COMM           READS  WRITES R_Kb     W_Kb    T FILE
----

If we see this, we know that the tool is properly running.

In the filetop terminal, we are going to see applications accessing files in realtime, so this will get pretty busy.

In the fourth new terminal, run:

.[root@node2 ~]#
----
/usr/share/bcc/tools/ext4slower
----

We should see this header in the ext4slower terminal, indicating that the tool is properly running:

----
Tracing ext4 operations slower than 10 ms
TIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME
----

In the ext4slower terminal, we probably won't see much until `yum update` starts installing the packages. Once it starts to install the packages, it's going to push the boundaries of what our virtual machine's storage can keep up with while delivering <10ms latency on ext4 operations. You will see operations taking longer than 10ms and the files these operations were operating on.

Finally, in the fifth new terminal, run:

.[root@node2 ~]#
----
/usr/share/bcc/tools/cachestat
----

We should see this header in the cachestat terminal, indicating that the tool is properly running:

----
    HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB
----

In the cachestat terminal, we will get to see in real time our hits and misses on the Linux memory cache. The second column is misses and the third column is hits. We should have mostly 0 misses for the first part of the `yum update`. Once we get to the installation of packages, we should see our misses start to increase.

Let's now use bpftool to verify what we have loaded in the kernel:

----
bpftool prog list
----

We should see output similar to:

----
1: kprobe  name do_entry  tag 8ac728a12cedba65  gpl
        loaded_at 2020-02-19T19:07:30-0500  uid 0
        xlated 2352B  jited 1408B  memlock 4096B
2: kprobe  name do_return  tag 6deef7357e7b4530  gpl
        loaded_at 2020-02-19T19:07:30-0500  uid 0
        xlated 64B  jited 61B  memlock 4096B
3: tracepoint  name sock__inet_sock  tag 6deef7357e7b4530  gpl
        loaded_at 2020-02-19T19:07:30-0500  uid 0
        xlated 64B  jited 61B  memlock 4096B

<< OUTPUT ABRIDGED >>
----

This shows us all the bpf programs presently loaded.

=== Observing the `yum update`

`yum update` goes through the following steps:

     * Updating repository metadata
     * Determining what packages on the system need to be updated
     * Downloading the appropriate packages for updates.
     * Installing the updates and removing old packages.
     * Verifying the updates have been successful.

Let's get started in our original terminal by running:

.[root@node2 ~]#
----
yum update -y
----

The first thing that yum does is updates repository metadata. This is going to create activity on our gethostlatency terminal and our tcplife terminal. We can look at those to see the network connections that yum establishes in real time.

We will see entries on our gethostlatency terminal similar to:

----
TIME      PID    COMM                  LATms HOST
08:45:23  75923  yum                    0.10 localhost
08:45:25  75924  yum                  375.39 subscription.rhsm.redhat.com
08:45:27  75926  yum                  109.50 subscription.rhsm.redhat.com
08:45:38  75927  yum                   10.23 cdn.redhat.com
08:45:39  75929  yum                   10.21 cdn.redhat.com
08:45:40  75931  yum                   10.18 cdn.redhat.com
----

that show yum looking up IP addresses for localhost, subscription.rhsm.redhat.com, and cdn.redhat.com. This makes it really easy to know what hosts our application is talking to.

Let's also look at the cachestat terminal and we should see output similar to:

----
    HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB
      14        0        0  100.00%            0       1681
    2768        0        0  100.00%            0       1699
     596        0        0  100.00%            0       1700
    4143        0        0  100.00%            0       1708
    3252        0        0  100.00%            0       1698

<< OUTPUT ABRIDGED >>
----

This shows that we are operating entirely out of cache and not having to go all the way to main memory at this point.

If we look at our tcplife terminal when yum has finished downloading packages, we will see output similar to:

----
PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
75963 yum        172.17.0.39     38054 2.16.30.83      443      23 138393 36375.04
75963 yum        172.17.0.39     38054 2.16.30.83      443      24 163378 36374.62
75963 yum        172.17.0.39     38054 2.16.30.83      443      22 163223 36374.69
----

that show us that yum has established a connection on 443 to 2.16.30.83 and that connection lasted for 36375.04 milliseconds, or 36.37504 seconds. This correlates to the amount of time yum spent downloading packages.

Next, yum will begin installing the updates and removing old packages. To do this, yum is going to use our disk and memory resources and so we will monitor this with filetop, ext4slower and cachestat.

In the filetop terminal, we will start to actually see files being read and written to disk. As yum reads files from the rpm, it then writes them out to the disk. Here is what the reads look like:

----
TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE
77699  yum              7      0      2       0       R stat.h;5e5574b8
77699  yum              3      0      0       0       R tc_defact.h;5.5574b8
77699  yum              1      0      0       0       R rpmsg.h;5e5574b8
77699  yum              2      0      0       0       R midi.h;5e5574b8
<< OUTPUT ABRIDGED >>
----

From the above output, we can see in the "T"ype column that these are "R"eads. Further, we see the counters in the "READS" column as greater than 0. This shows us in real time what yum is doing with files on the system.

Further, on the ext4slower terminal, we will start to see ext4 operations take longer than 10ms and these will start to show:

----
Tracing ext4 operations slower than 10 ms
TIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME
09:22:58 b'yum'         77726  S 0       0         567.45 b'packages.db-journal'
09:22:58 b'yum'         77726  S 0       0          14.21 b'packages.db-journal'
09:22:58 b'yum'         77726  S 0       0          14.48 b'packages.db-journal'
09:22:58 b'yum'         77726  S 0       0          13.83 b'packages.db-journal'
09:22:58 b'yum'         77726  S 0       0          14.16 b'packages.db-journal'
09:22:59 b'yum'         77726  S 0       0          10.07 b'packages.db-journal'
09:22:59 b'yum'         77726  S 0       0          27.65 b'packages.db'
<< OUTPUT ABRIDGED >>
----

In the above output, we see the file that yum was working on and the latency in the "LAT(ms)" column, which shows us that the longest latency was 567.45 milliseconds accessing packages.db-journal. If we wish to improve the speed of `yum update` on this system by reducing latency, we may want to look at upgrading the underlying storage of this system.

Further, if we look at the cachestat terminal, we'll see that the number of misses on the cache has gone up during the installation procedure as we are starting to need access to memory locations that are not cached:

----
    HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB
       0       62        0    0.00%            0       1701
       0       52        0    0.00%            0       1702
      45        2        0   95.74%            0       1701
    5721     3777        0   60.23%            0       1716
   18683     6606        0   73.88%            0       1747
   14853     6223        0   70.47%            0       1778
       0        2        0    0.00%            0       1778

<< OUTPUT ABRIDGED >>
----

If we keep watching cachestat, we'll notice that the number of misses goes back down to zero after the `yum update` is done. This is because when the `yum update` is finished, our virtual machine is idle and there is very little running that needs access to memory.

[discrete]
== Additional Resources


NOTE: You are not required to reference any additional resources for these exercises.  This is informational only.

    * link:https://www.redhat.com/en/blog/bcc-tools-brings-dynamic-kernel-tracing-red-hat-enterprise-linux-81[bcc-tools brings dynamic kernel tracing to Red Hat Enterprise Linux 8.1]
    * link:https://www.redhat.com/en/blog/why-networkmanager-talking-staticredhatcom-find-out-bcc-tools[Why is NetworkManager talking to static.redhat.com? Find out with bcc-tools!]
    * link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/analyzing-system-performance-with-bpf-compiler_collection_managing-monitoring-and-updating-the-kernel[Analyzing System Performance with BPF Compiler Collection]
    * link:http://www.brendangregg.com/ebpf.html[Linux Extended BPF (eBPF Tracing Tools) - Brendan Gregg]

[discrete]
== End of Unit

link:../RHEL8-Workshop.adoc#toc[Return to TOC]

////
Alway end files with a blank line to avoid include problems.
////
